<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>code examples</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="nl">
<meta name="settings" content="number_lines,use_css,no_foldcolumn,expand_tabs,line_ids,prevent_copy=">
<meta name="colorscheme" content="unkiwii">
<style type="text/css">
<!--
pre { font-family: monospace; color: #ffffff; background-color: #000000; }
body { font-family: monospace; color: #ffffff; background-color: #000000; }
* { font-size: 1em; }
.Comment { color: #666666; }
.Constant { color: #FCE94F; font-weight: bold; }
.LineNr { color: #FCE94F; }
.Statement { color: #34E2E2; font-weight: bold; }
.PreProc { color: #EF2929; font-weight: bold; }
.Type { color: #8AE234; font-weight: bold; }
-->
</style>

<script type='text/javascript'>
<!--

/* function to open any folds containing a jumped-to line before jumping to it */
function JumpToLine()
{
  var lineNum;
  lineNum = window.location.hash;
  lineNum = lineNum.substr(1); /* strip off '#' */

  if (lineNum.indexOf('L') == -1) {
    lineNum = 'L'+lineNum;
  }
  lineElem = document.getElementById(lineNum);
  /* Always jump to new location even if the line was hidden inside a fold, or
   * we corrected the raw number to a line ID.
   */
  if (lineElem) {
    lineElem.scrollIntoView(true);
  }
  return true;
}
if ('onhashchange' in window) {
  window.onhashchange = JumpToLine;
}

-->
</script>
</head>
<body onload='JumpToLine();'>
<pre id='vimCodeElement'>
<span id="L1" class="LineNr">  1 </span><span class="Comment"># IMPORTANT: All code in this file is valid, compilable code. All compiler errors will be inside a comment. You can use</span>
<span id="L2" class="LineNr">  2 </span><span class="Comment"># this file as a quick reference for the language.</span>
<span id="L3" class="LineNr">  3 </span>
<span id="L4" class="LineNr">  4 </span><span class="Comment"># if you want to view this file with a highlighted syntax you can do one (or both) of this things:</span>
<span id="L5" class="LineNr">  5 </span><span class="Comment">#</span>
<span id="L6" class="LineNr">  6 </span><span class="Comment">#   1. Download 'vim/syntax/nl.vim', open this file with vim and use that syntax file to highlight correctly.</span>
<span id="L7" class="LineNr">  7 </span><span class="Comment">#</span>
<span id="L8" class="LineNr">  8 </span><span class="Comment">#   2. Go to <a href="http://unkiwii.github.io/newlang/code_examples.html">http://unkiwii.github.io/newlang/code_examples.html</a> and see this file rendered as an html (but the .html</span>
<span id="L9" class="LineNr">  9 </span><span class="Comment">#      can be older than this file)</span>
<span id="L10" class="LineNr"> 10 </span>
<span id="L11" class="LineNr"> 11 </span>
<span id="L12" class="LineNr"> 12 </span><span class="Comment">########## comments ##########</span>
<span id="L13" class="LineNr"> 13 </span>
<span id="L14" class="LineNr"> 14 </span><span class="Comment"># any line starting with a '#' character is a comment, there are no multi-line comments</span>
<span id="L15" class="LineNr"> 15 </span>
<span id="L16" class="LineNr"> 16 </span>
<span id="L17" class="LineNr"> 17 </span><span class="Comment">########## importing code from other files and libraries ##########</span>
<span id="L18" class="LineNr"> 18 </span>
<span id="L19" class="LineNr"> 19 </span><span class="Comment"># importing a file in same folder</span>
<span id="L20" class="LineNr"> 20 </span>
<span id="L21" class="LineNr"> 21 </span><span class="PreProc">import</span> aFile.
<span id="L22" class="LineNr"> 22 </span>
<span id="L23" class="LineNr"> 23 </span><span class="Comment"># importing a file in a subfolder</span>
<span id="L24" class="LineNr"> 24 </span>
<span id="L25" class="LineNr"> 25 </span><span class="PreProc">import</span> foo/aFile.
<span id="L26" class="LineNr"> 26 </span><span class="PreProc">import</span> foo/bar/aLib.
<span id="L27" class="LineNr"> 27 </span>
<span id="L28" class="LineNr"> 28 </span><span class="Comment"># importing a file in a parent folder</span>
<span id="L29" class="LineNr"> 29 </span>
<span id="L30" class="LineNr"> 30 </span><span class="PreProc">import</span> ../aFile.
<span id="L31" class="LineNr"> 31 </span><span class="PreProc">import</span> ../../aLib.
<span id="L32" class="LineNr"> 32 </span><span class="PreProc">import</span> ../foo/aFile.
<span id="L33" class="LineNr"> 33 </span><span class="PreProc">import</span> ../foo/bar/aLib.
<span id="L34" class="LineNr"> 34 </span>
<span id="L35" class="LineNr"> 35 </span>
<span id="L36" class="LineNr"> 36 </span><span class="Comment">########## literals ##########</span>
<span id="L37" class="LineNr"> 37 </span>
<span id="L38" class="LineNr"> 38 </span><span class="Comment"># this language has only 2 literals: Numbers and Strings</span>
<span id="L39" class="LineNr"> 39 </span><span class="Comment">#</span>
<span id="L40" class="LineNr"> 40 </span><span class="Comment"># Numbers:</span>
<span id="L41" class="LineNr"> 41 </span><span class="Comment">#   123       # an integer</span>
<span id="L42" class="LineNr"> 42 </span><span class="Comment">#   0,123     # a real</span>
<span id="L43" class="LineNr"> 43 </span><span class="Comment">#</span>
<span id="L44" class="LineNr"> 44 </span><span class="Comment"># Strings:</span>
<span id="L45" class="LineNr"> 45 </span><span class="Comment">#   &quot;Hello World!&quot;  # inside double quotes</span>
<span id="L46" class="LineNr"> 46 </span><span class="Comment">#</span>
<span id="L47" class="LineNr"> 47 </span><span class="Comment"># in C, for example, a literal value is a legal statement, but not here, you can't just write a number or a string alone</span>
<span id="L48" class="LineNr"> 48 </span><span class="Comment"># in a line of code and expect it to work.</span>
<span id="L49" class="LineNr"> 49 </span>
<span id="L50" class="LineNr"> 50 </span>
<span id="L51" class="LineNr"> 51 </span><span class="Comment">########## variable declarations ##########</span>
<span id="L52" class="LineNr"> 52 </span>
<span id="L53" class="LineNr"> 53 </span><span class="Comment"># the way to declare a variable is:</span>
<span id="L54" class="LineNr"> 54 </span>
<span id="L55" class="LineNr"> 55 </span><span class="Type">Type</span> name := <span class="Constant">&quot;value&quot;</span>.
<span id="L56" class="LineNr"> 56 </span>
<span id="L57" class="LineNr"> 57 </span><span class="Comment"># where:</span>
<span id="L58" class="LineNr"> 58 </span><span class="Comment">#   Type    is the type (or class) of the variable, any type must start with a upper case character and be followed by</span>
<span id="L59" class="LineNr"> 59 </span><span class="Comment">#           any upper or lower case character, as in: Type, Object, HTTPServer, etc.</span>
<span id="L60" class="LineNr"> 60 </span><span class="Comment">#</span>
<span id="L61" class="LineNr"> 61 </span><span class="Comment">#   name    is the name of the variable, any name must start with a lower case character and be followed by any upper or</span>
<span id="L62" class="LineNr"> 62 </span><span class="Comment">#           lower case character: aName, someVariable, thisNumber, etc.</span>
<span id="L63" class="LineNr"> 63 </span><span class="Comment">#</span>
<span id="L64" class="LineNr"> 64 </span><span class="Comment">#   :=      is the assignation operator, unlike other languages the ':=' is used instead of the usual '=' for</span>
<span id="L65" class="LineNr"> 65 </span><span class="Comment">#           assignation, because the '=' can be used to compare if two values are the same.</span>
<span id="L66" class="LineNr"> 66 </span><span class="Comment">#</span>
<span id="L67" class="LineNr"> 67 </span><span class="Comment">#   value   is the value assigned to the variable, this can be a literal, another identifier (name of another variable)</span>
<span id="L68" class="LineNr"> 68 </span><span class="Comment">#           or any block evaluation that returns a value.</span>
<span id="L69" class="LineNr"> 69 </span><span class="Comment">#</span>
<span id="L70" class="LineNr"> 70 </span><span class="Comment">#   .       the dot character marks the end of any statement in the language</span>
<span id="L71" class="LineNr"> 71 </span><span class="Comment">#</span>
<span id="L72" class="LineNr"> 72 </span><span class="Comment"># NOTE: a variable can't be declared without an initialization, i.e. in C you can have a 'int a;' declared but not</span>
<span id="L73" class="LineNr"> 73 </span><span class="Comment"># initialized, in this language that is illegal.</span>
<span id="L74" class="LineNr"> 74 </span>
<span id="L75" class="LineNr"> 75 </span><span class="Comment"># you can declare a variable anywhere, it's scope is defined by the place of it's declaration, if you declare it here,</span>
<span id="L76" class="LineNr"> 76 </span><span class="Comment"># it will be global (accessible by the whole code of the program)</span>
<span id="L77" class="LineNr"> 77 </span>
<span id="L78" class="LineNr"> 78 </span><span class="Type">Number</span> aGlobalNumber := 123.
<span id="L79" class="LineNr"> 79 </span><span class="Type">String</span> aGlobalString := <span class="Constant">&quot;Hello World&quot;</span>.
<span id="L80" class="LineNr"> 80 </span>
<span id="L81" class="LineNr"> 81 </span><span class="Comment"># if you declare them inside a block of code it will local to that block of code and invisible from anywhere else; same</span>
<span id="L82" class="LineNr"> 82 </span><span class="Comment"># with a type.</span>
<span id="L83" class="LineNr"> 83 </span>
<span id="L84" class="LineNr"> 84 </span>
<span id="L85" class="LineNr"> 85 </span><span class="Comment">########## types declarations ##########</span>
<span id="L86" class="LineNr"> 86 </span>
<span id="L87" class="LineNr"> 87 </span><span class="Comment"># this is a multi paradigm language, and one of the paradigms that supports is object oriented programming, for that you</span>
<span id="L88" class="LineNr"> 88 </span><span class="Comment"># must be allowed to write your own objects, to accomplish this you must declare a new type, as a blueprint for objects</span>
<span id="L89" class="LineNr"> 89 </span><span class="Comment"># to be created from that blueprint, like a 'class' in Java or C++</span>
<span id="L90" class="LineNr"> 90 </span>
<span id="L91" class="LineNr"> 91 </span><span class="PreProc">type</span> <span class="Type">NewType</span>
<span id="L92" class="LineNr"> 92 </span>  <span class="Comment"># member declaration: every instance of 'NewType' will have it's own 'data'</span>
<span id="L93" class="LineNr"> 93 </span>  <span class="Type">String</span> data := <span class="Constant">&quot;some data&quot;</span>.
<span id="L94" class="LineNr"> 94 </span>
<span id="L95" class="LineNr"> 95 </span>  <span class="Comment"># static member declaration: only one instance of this object for all the instances of 'NewType'</span>
<span id="L96" class="LineNr"> 96 </span>  <span class="PreProc">static</span> <span class="Type">Number</span> id := 123.
<span id="L97" class="LineNr"> 97 </span>
<span id="L98" class="LineNr"> 98 </span>  <span class="Comment"># method declaration: this block of code will be associated with every new instance of 'NewType', it must be evaluated</span>
<span id="L99" class="LineNr"> 99 </span>  <span class="Comment"># by passing the message 'someCode' to an object of type 'NewType':</span>
<span id="L100" class="LineNr">100 </span>  <span class="Comment">#</span>
<span id="L101" class="LineNr">101 </span>  <span class="Comment">#   anObject someCode.</span>
<span id="L102" class="LineNr">102 </span>  <span class="Comment">#</span>
<span id="L103" class="LineNr">103 </span>  [ <span class="Type">String</span> someCode |
<span id="L104" class="LineNr">104 </span>    <span class="Comment"># ...</span>
<span id="L105" class="LineNr">105 </span>    <span class="Statement">return</span> (<span class="Statement">self</span> data).
<span id="L106" class="LineNr">106 </span>  ].
<span id="L107" class="LineNr">107 </span>
<span id="L108" class="LineNr">108 </span>  <span class="Comment"># static method declaration: this block of code is associated with the type 'NewType' and it must be evaluated by</span>
<span id="L109" class="LineNr">109 </span>  <span class="Comment"># passing the message 'doSomething' to the 'NewType' type:</span>
<span id="L110" class="LineNr">110 </span>  <span class="Comment">#</span>
<span id="L111" class="LineNr">111 </span>  <span class="Comment">#   NewType doSomething.</span>
<span id="L112" class="LineNr">112 </span>  <span class="Comment">#</span>
<span id="L113" class="LineNr">113 </span>  <span class="PreProc">static</span> [ <span class="Statement">void</span> doSomething |
<span id="L114" class="LineNr">114 </span>    <span class="Comment"># ...</span>
<span id="L115" class="LineNr">115 </span>  ].
<span id="L116" class="LineNr">116 </span>
<span id="L117" class="LineNr">117 </span>  <span class="Comment"># in this language there are no constants, for that reason if you want to have a constant value just use a method that</span>
<span id="L118" class="LineNr">118 </span>  <span class="Comment"># returns a literal value</span>
<span id="L119" class="LineNr">119 </span>  [ <span class="Type">Number</span> pi |
<span id="L120" class="LineNr">120 </span>    <span class="Statement">return</span> 3,1415.
<span id="L121" class="LineNr">121 </span>  ].
<span id="L122" class="LineNr">122 </span>
<span id="L123" class="LineNr">123 </span><span class="Comment"># maybe you noticed that no 'public' or 'private' was used, that's because here there are not access modifiers, you can</span>
<span id="L124" class="LineNr">124 </span><span class="Comment"># only send messages to an object, never access it's internal representation:</span>
<span id="L125" class="LineNr">125 </span><span class="Comment">#</span>
<span id="L126" class="LineNr">126 </span><span class="Comment">#   EVERY MEMBER OF AN OBJECT IS PRIVATE TO THAT OBJECT.</span>
<span id="L127" class="LineNr">127 </span><span class="Comment">#</span>
<span id="L128" class="LineNr">128 </span><span class="Comment">#   EVERY METHOD OF AN OBJECT IS PUBLIC VISIBLE TO EVERY OTHER OBJECT.</span>
<span id="L129" class="LineNr">129 </span><span class="Comment">#</span>
<span id="L130" class="LineNr">130 </span><span class="Comment"># you can only evaluate code of an object, never access it's data.</span>
<span id="L131" class="LineNr">131 </span>
<span id="L132" class="LineNr">132 </span>
<span id="L133" class="LineNr">133 </span><span class="Comment">########## blocks of code ##########</span>
<span id="L134" class="LineNr">134 </span>
<span id="L135" class="LineNr">135 </span><span class="Comment"># there are 3 types of blocks:</span>
<span id="L136" class="LineNr">136 </span><span class="Comment">#</span>
<span id="L137" class="LineNr">137 </span><span class="Comment">#   global    these work just like any global function from C, they are available from any part of the program and can</span>
<span id="L138" class="LineNr">138 </span><span class="Comment">#             be evaluated from anywhere, they had a name for that.</span>
<span id="L139" class="LineNr">139 </span>
<span id="L140" class="LineNr">140 </span><span class="Comment">#   methods   these are blocks of code associated with a particular type and in run time with a particular object.</span>
<span id="L141" class="LineNr">141 </span><span class="Comment">#</span>
<span id="L142" class="LineNr">142 </span><span class="Comment">#   lambdas   anonymous blocks of code that are used right in place or passed to other blocks of code as a parameter to</span>
<span id="L143" class="LineNr">143 </span><span class="Comment">#             be executed later.</span>
<span id="L144" class="LineNr">144 </span><span class="Comment">#</span>
<span id="L145" class="LineNr">145 </span><span class="Comment"># all of them are declared in the same way and are always enclosed in square brackets '[' and ']', a block is declared</span>
<span id="L146" class="LineNr">146 </span><span class="Comment"># as follows:</span>
<span id="L147" class="LineNr">147 </span>
<span id="L148" class="LineNr">148 </span>[ <span class="Type">ReturnType</span> blockName |
<span id="L149" class="LineNr">149 </span>  <span class="Comment"># block code</span>
<span id="L150" class="LineNr">150 </span>].
<span id="L151" class="LineNr">151 </span>
<span id="L152" class="LineNr">152 </span><span class="Comment"># where:</span>
<span id="L153" class="LineNr">153 </span><span class="Comment">#   [             marks the start of a block.</span>
<span id="L154" class="LineNr">154 </span><span class="Comment">#</span>
<span id="L155" class="LineNr">155 </span><span class="Comment">#   ReturnType    is the type of the result returned by the block of code. If the block doesn't return anything a</span>
<span id="L156" class="LineNr">156 </span><span class="Comment">#                 special keyword: 'void' is used to denote this fact.</span>
<span id="L157" class="LineNr">157 </span><span class="Comment">#</span>
<span id="L158" class="LineNr">158 </span><span class="Comment">#   blockName     is the name of the block, as with a variable, any name must start with a lower case character and be</span>
<span id="L159" class="LineNr">159 </span><span class="Comment">#                 followed by any upper or lower case character: aName, someVariable, thisNumber, etc.</span>
<span id="L160" class="LineNr">160 </span><span class="Comment">#</span>
<span id="L161" class="LineNr">161 </span><span class="Comment">#   |             the vertical bar character ('|'), marks the end of the header of the block and the beginning of the</span>
<span id="L162" class="LineNr">162 </span><span class="Comment">#                 body of the block that has the code.</span>
<span id="L163" class="LineNr">163 </span><span class="Comment">#</span>
<span id="L164" class="LineNr">164 </span><span class="Comment">#   ]             marks the end of a block.</span>
<span id="L165" class="LineNr">165 </span><span class="Comment">#</span>
<span id="L166" class="LineNr">166 </span><span class="Comment">#   .             as with any other statement a block declaration ends with a dot character</span>
<span id="L167" class="LineNr">167 </span><span class="Comment">#</span>
<span id="L168" class="LineNr">168 </span><span class="Comment"># blocks have two important parts, the header and the body, they are separated with a vertical bar '|' character:</span>
<span id="L169" class="LineNr">169 </span><span class="Comment">#</span>
<span id="L170" class="LineNr">170 </span><span class="Comment">#   [ header | body ].</span>
<span id="L171" class="LineNr">171 </span><span class="Comment">#</span>
<span id="L172" class="LineNr">172 </span><span class="Comment"># in the header we define the return type, the name of the block, the type and name of the parameters.</span>
<span id="L173" class="LineNr">173 </span><span class="Comment"># in the body we define the executable code of the block itself.</span>
<span id="L174" class="LineNr">174 </span><span class="Comment">#</span>
<span id="L175" class="LineNr">175 </span><span class="Comment"># in some programming languages, the name and parameters of a block of code are separated, for example we will write a</span>
<span id="L176" class="LineNr">176 </span><span class="Comment"># function (and it's call) in C that receives 2 integer numbers and returns (as an integer) it's sum:</span>
<span id="L177" class="LineNr">177 </span><span class="Comment">#</span>
<span id="L178" class="LineNr">178 </span><span class="Comment">#   int add(int a, int b) {</span>
<span id="L179" class="LineNr">179 </span><span class="Comment">#     return a + b;</span>
<span id="L180" class="LineNr">180 </span><span class="Comment">#   }</span>
<span id="L181" class="LineNr">181 </span><span class="Comment">#</span>
<span id="L182" class="LineNr">182 </span><span class="Comment">#   add(4, 5);</span>
<span id="L183" class="LineNr">183 </span><span class="Comment">#</span>
<span id="L184" class="LineNr">184 </span><span class="Comment"># the name of that function is 'add', it's signature is 'int add(int, int), and has 2 parameters: 'a' and 'b' both</span>
<span id="L185" class="LineNr">185 </span><span class="Comment"># integers, in this language the same function is written like this:</span>
<span id="L186" class="LineNr">186 </span>
<span id="L187" class="LineNr">187 </span>[ <span class="Type">Number</span> add: <span class="Type">Number</span> a and: <span class="Type">Number</span> b |
<span id="L188" class="LineNr">188 </span>  <span class="Statement">return</span> a + b.
<span id="L189" class="LineNr">189 </span>].
<span id="L190" class="LineNr">190 </span>
<span id="L191" class="LineNr">191 </span>add: 4 and: 5.
<span id="L192" class="LineNr">192 </span>
<span id="L193" class="LineNr">193 </span><span class="Comment"># the name of the block is 'add:and:' and it's signature is 'add: Number and: Number', and has 2 parameters: 'a' and 'b'</span>
<span id="L194" class="LineNr">194 </span><span class="Comment"># both Numbers. In this example maybe it's better the C code, but see the next example:</span>
<span id="L195" class="LineNr">195 </span><span class="Comment">#</span>
<span id="L196" class="LineNr">196 </span><span class="Comment">#   void iterate(int from, int to, void (do*)(int)) {</span>
<span id="L197" class="LineNr">197 </span><span class="Comment">#     ...</span>
<span id="L198" class="LineNr">198 </span><span class="Comment">#   }</span>
<span id="L199" class="LineNr">199 </span><span class="Comment">#</span>
<span id="L200" class="LineNr">200 </span><span class="Comment">#   iterate(1, 10, &amp;func);</span>
<span id="L201" class="LineNr">201 </span><span class="Comment">#</span>
<span id="L202" class="LineNr">202 </span><span class="Comment"># and the language code:</span>
<span id="L203" class="LineNr">203 </span>
<span id="L204" class="LineNr">204 </span><span class="Comment"># the declaration is a bit more verbose</span>
<span id="L205" class="LineNr">205 </span>[ <span class="Statement">void</span> from: <span class="Type">Number</span> start to: <span class="Type">Number</span> end do: [ value: <span class="Type">Number</span> ] aBlock |
<span id="L206" class="LineNr">206 </span>  <span class="Comment"># code</span>
<span id="L207" class="LineNr">207 </span>].
<span id="L208" class="LineNr">208 </span>
<span id="L209" class="LineNr">209 </span><span class="Comment"># but the evaluation is just as simple as it can get:</span>
<span id="L210" class="LineNr">210 </span>from: 1 to: 10 do: [
<span id="L211" class="LineNr">211 </span>  <span class="Comment"># code</span>
<span id="L212" class="LineNr">212 </span>].
<span id="L213" class="LineNr">213 </span>
<span id="L214" class="LineNr">214 </span><span class="Comment"># even more, as the literals '1' and '10' are of type Number we can add that block as a method of Number type:</span>
<span id="L215" class="LineNr">215 </span><span class="PreProc">type</span> <span class="Type">Number</span>
<span id="L216" class="LineNr">216 </span>  [ <span class="Statement">void</span> to: <span class="Type">Number</span> stop do: [ value: <span class="Type">Number</span> ] aBlock |
<span id="L217" class="LineNr">217 </span>    <span class="Comment"># code</span>
<span id="L218" class="LineNr">218 </span>  ].
<span id="L219" class="LineNr">219 </span>
<span id="L220" class="LineNr">220 </span><span class="Comment"># and evaluate the above method as:</span>
<span id="L221" class="LineNr">221 </span>1 to: 10 do: [
<span id="L222" class="LineNr">222 </span>  <span class="Comment"># code</span>
<span id="L223" class="LineNr">223 </span>].
<span id="L224" class="LineNr">224 </span>
<span id="L225" class="LineNr">225 </span><span class="Comment"># note that we are not chaining a call, that is just a call to a single block of code, things that in C-like languages</span>
<span id="L226" class="LineNr">226 </span><span class="Comment"># you must write as 'name(param1, param2)' you must write it here as 'name: param1 name2: param2' it may sound silly,</span>
<span id="L227" class="LineNr">227 </span><span class="Comment"># but wait a little and you should see the power behind this structure.</span>
<span id="L228" class="LineNr">228 </span>
<span id="L229" class="LineNr">229 </span><span class="Comment"># here are multiple examples of various types of blocks that return and receive objects.</span>
<span id="L230" class="LineNr">230 </span>
<span id="L231" class="LineNr">231 </span><span class="Comment">### no return, no parameters</span>
<span id="L232" class="LineNr">232 </span><span class="Comment"># declare</span>
<span id="L233" class="LineNr">233 </span>[ <span class="Statement">void</span> name |
<span id="L234" class="LineNr">234 </span>  <span class="Comment"># code</span>
<span id="L235" class="LineNr">235 </span>].
<span id="L236" class="LineNr">236 </span><span class="Comment"># evaluate</span>
<span id="L237" class="LineNr">237 </span>name.
<span id="L238" class="LineNr">238 </span>
<span id="L239" class="LineNr">239 </span><span class="Comment">### return, no parameters</span>
<span id="L240" class="LineNr">240 </span><span class="Comment"># declare</span>
<span id="L241" class="LineNr">241 </span>[ <span class="Type">Number</span> name |
<span id="L242" class="LineNr">242 </span>  <span class="Comment"># code</span>
<span id="L243" class="LineNr">243 </span>  <span class="Statement">return</span> 0.
<span id="L244" class="LineNr">244 </span>].
<span id="L245" class="LineNr">245 </span><span class="Comment"># evaluate</span>
<span id="L246" class="LineNr">246 </span><span class="Type">Number</span> result := name.
<span id="L247" class="LineNr">247 </span>
<span id="L248" class="LineNr">248 </span><span class="Comment">### multiple returns (yes, you can return more than one object from a block of code), no parameters</span>
<span id="L249" class="LineNr">249 </span><span class="Comment"># declare</span>
<span id="L250" class="LineNr">250 </span>[ (<span class="Type">Number</span>, <span class="Type">String</span>) name |
<span id="L251" class="LineNr">251 </span>  <span class="Comment"># code</span>
<span id="L252" class="LineNr">252 </span>  <span class="Statement">return</span> (0, <span class="Constant">&quot;Hello&quot;</span>).
<span id="L253" class="LineNr">253 </span>].
<span id="L254" class="LineNr">254 </span><span class="Comment"># evaluate</span>
<span id="L255" class="LineNr">255 </span><span class="Type">Number</span> a, <span class="Type">String</span> b := name.
<span id="L256" class="LineNr">256 </span>
<span id="L257" class="LineNr">257 </span><span class="Comment">### no return, 1 parameter</span>
<span id="L258" class="LineNr">258 </span><span class="Comment"># declare</span>
<span id="L259" class="LineNr">259 </span>[ <span class="Statement">void</span> name: <span class="Type">String</span> param |
<span id="L260" class="LineNr">260 </span>  <span class="Comment"># code</span>
<span id="L261" class="LineNr">261 </span>].
<span id="L262" class="LineNr">262 </span><span class="Comment"># evaluate</span>
<span id="L263" class="LineNr">263 </span>name: <span class="Constant">&quot;Hello&quot;</span>.
<span id="L264" class="LineNr">264 </span>
<span id="L265" class="LineNr">265 </span><span class="Comment">### return, 1 parameter</span>
<span id="L266" class="LineNr">266 </span><span class="Comment"># declare</span>
<span id="L267" class="LineNr">267 </span>[ <span class="Type">Number</span> name: <span class="Type">Number</span> param |
<span id="L268" class="LineNr">268 </span>  <span class="Statement">return</span> param + 123.
<span id="L269" class="LineNr">269 </span>].
<span id="L270" class="LineNr">270 </span><span class="Comment"># evaluate</span>
<span id="L271" class="LineNr">271 </span><span class="Type">Number</span> result := name: 12.
<span id="L272" class="LineNr">272 </span>
<span id="L273" class="LineNr">273 </span><span class="Comment">### multiple returns, 1 parameter</span>
<span id="L274" class="LineNr">274 </span><span class="Comment"># declare</span>
<span id="L275" class="LineNr">275 </span>[ (<span class="Type">Number</span>, <span class="Type">String</span>) name: <span class="Type">Number</span> param |
<span id="L276" class="LineNr">276 </span>  <span class="Statement">return</span> (param + 123, param asString).
<span id="L277" class="LineNr">277 </span>].
<span id="L278" class="LineNr">278 </span><span class="Comment"># evaluate</span>
<span id="L279" class="LineNr">279 </span><span class="Type">Number</span> a, <span class="Type">String</span> b := name: 123.
<span id="L280" class="LineNr">280 </span>
<span id="L281" class="LineNr">281 </span><span class="Comment">### no return, more than 1 parameter</span>
<span id="L282" class="LineNr">282 </span><span class="Comment"># declare</span>
<span id="L283" class="LineNr">283 </span>[ <span class="Statement">void</span> name: <span class="Type">Number</span> param, and: <span class="Type">String</span> param2 |
<span id="L284" class="LineNr">284 </span>  <span class="Comment"># code</span>
<span id="L285" class="LineNr">285 </span>].
<span id="L286" class="LineNr">286 </span><span class="Comment"># evaluate</span>
<span id="L287" class="LineNr">287 </span>name: 123 and: <span class="Constant">&quot;Hello&quot;</span>.
<span id="L288" class="LineNr">288 </span>
<span id="L289" class="LineNr">289 </span><span class="Comment">### return, more than 1 parameter</span>
<span id="L290" class="LineNr">290 </span><span class="Comment"># declare</span>
<span id="L291" class="LineNr">291 </span>[ <span class="Type">Number</span> name: <span class="Type">Number</span> param and: <span class="Type">Number</span> param2 |
<span id="L292" class="LineNr">292 </span>  <span class="Statement">return</span> param + param2.
<span id="L293" class="LineNr">293 </span>].
<span id="L294" class="LineNr">294 </span><span class="Comment"># evaluate</span>
<span id="L295" class="LineNr">295 </span><span class="Type">Number</span> result := name: 123 and: 345.
<span id="L296" class="LineNr">296 </span>
<span id="L297" class="LineNr">297 </span><span class="Comment">### multiple retuns, more than 1 parameter</span>
<span id="L298" class="LineNr">298 </span><span class="Comment"># declare</span>
<span id="L299" class="LineNr">299 </span>[ (<span class="Type">Number</span>, <span class="Type">Number</span>) sqrt: <span class="Type">Number</span> a pow: <span class="Type">Number</span> b to: <span class="Type">Number</span> c |
<span id="L300" class="LineNr">300 </span>  <span class="Statement">return</span> (a sqrt, b pow: c).
<span id="L301" class="LineNr">301 </span>].
<span id="L302" class="LineNr">302 </span><span class="Comment"># evaluate</span>
<span id="L303" class="LineNr">303 </span><span class="Type">Number</span> s, <span class="Type">Number</span> p := sqrt: 25 pow: 3 to: 4.
<span id="L304" class="LineNr">304 </span>
<span id="L305" class="LineNr">305 </span><span class="Comment"># in resume, the header has the following structure:</span>
<span id="L306" class="LineNr">306 </span>[ <span class="Type">ReturnType</span> name1: <span class="Type">Type1</span> param1 name2: <span class="Type">Type2</span> param2 name3: <span class="Type">Type3</span> param3 |
<span id="L307" class="LineNr">307 </span>  <span class="Comment"># code</span>
<span id="L308" class="LineNr">308 </span>].
<span id="L309" class="LineNr">309 </span>
<span id="L310" class="LineNr">310 </span><span class="Comment"># where:</span>
<span id="L311" class="LineNr">311 </span><span class="Comment">#</span>
<span id="L312" class="LineNr">312 </span><span class="Comment">#   ReturnType    can be any type or 'void' when no returning</span>
<span id="L313" class="LineNr">313 </span><span class="Comment">#</span>
<span id="L314" class="LineNr">314 </span><span class="Comment">#   name1         is the name of the first part of the name of the block, if no parameters are passed this will be the</span>
<span id="L315" class="LineNr">315 </span><span class="Comment">#                 name of the block, but if a parameter is passed then a ':' is needed at the end of the name with one</span>
<span id="L316" class="LineNr">316 </span><span class="Comment">#                 exception: for methods with only 1 parameter you can skip the ':' character to declare a binary</span>
<span id="L317" class="LineNr">317 </span><span class="Comment">#                 operator like '+', '/' or '&amp;'.</span>
<span id="L318" class="LineNr">318 </span><span class="Comment">#</span>
<span id="L319" class="LineNr">319 </span><span class="Comment">#   Type1         is the type of the first parameter, it could be any type but never 'void'.</span>
<span id="L320" class="LineNr">320 </span><span class="Comment">#</span>
<span id="L321" class="LineNr">321 </span><span class="Comment">#   param1        is the name of the first parameter, this is the name used in the code of the block to refer to the</span>
<span id="L322" class="LineNr">322 </span><span class="Comment">#                 first parameter, it could be any identifier valid name.</span>
<span id="L323" class="LineNr">323 </span><span class="Comment">#</span>
<span id="L324" class="LineNr">324 </span><span class="Comment"># the rest of names, types and params are the ones for the rest of the parameters in the block, you can pass any number</span>
<span id="L325" class="LineNr">325 </span><span class="Comment"># of parameter to a block and the name is formed by: 'name1:name2:name3:...' and so on</span>
<span id="L326" class="LineNr">326 </span>
<span id="L327" class="LineNr">327 </span><span class="Comment"># IMPORTANT: there is an exception to all this rules, read this piece:</span>
<span id="L328" class="LineNr">328 </span>
<span id="L329" class="LineNr">329 </span>[ <span class="Type">Number</span> pi |
<span id="L330" class="LineNr">330 </span>  <span class="Statement">return</span> 3,14.
<span id="L331" class="LineNr">331 </span>].
<span id="L332" class="LineNr">332 </span>
<span id="L333" class="LineNr">333 </span><span class="Comment"># and this one:</span>
<span id="L334" class="LineNr">334 </span>
<span id="L335" class="LineNr">335 </span><span class="Type">Number</span> index := 0.
<span id="L336" class="LineNr">336 </span><span class="Type">Number</span> size := 10.
<span id="L337" class="LineNr">337 </span>[ <span class="Type">Boolean</span> test |
<span id="L338" class="LineNr">338 </span>  <span class="Statement">return</span> index &lt; size.
<span id="L339" class="LineNr">339 </span>].
<span id="L340" class="LineNr">340 </span>
<span id="L341" class="LineNr">341 </span><span class="Comment"># that is a block that has only one return statement that returns just one object and doesn't receive anything, in this</span>
<span id="L342" class="LineNr">342 </span><span class="Comment"># case and ONLY IN THIS CASE you can skip the header completely:</span>
<span id="L343" class="LineNr">343 </span>
<span id="L344" class="LineNr">344 </span>[ 3,14 ]. <span class="Comment"># pi</span>
<span id="L345" class="LineNr">345 </span>
<span id="L346" class="LineNr">346 </span>[ index &lt; size ]. <span class="Comment"># test</span>
<span id="L347" class="LineNr">347 </span>
<span id="L348" class="LineNr">348 </span><span class="Comment"># this may seems useless but here you can read a real world example, a foreach algorithm:</span>
<span id="L349" class="LineNr">349 </span>[ <span class="Statement">void</span> from: <span class="Type">Number</span> start to: <span class="Type">Number</span> end do: [ <span class="Statement">void</span> value ] aBlock |
<span id="L350" class="LineNr">350 </span>  <span class="Type">Number</span> index := start.
<span id="L351" class="LineNr">351 </span>  [ index &lt; end ] whileTrue: [
<span id="L352" class="LineNr">352 </span>    do value.
<span id="L353" class="LineNr">353 </span>    index := index + 1.
<span id="L354" class="LineNr">354 </span>  ].
<span id="L355" class="LineNr">355 </span>].
<span id="L356" class="LineNr">356 </span>
<span id="L357" class="LineNr">357 </span><span class="Comment"># here is the 'whileTrue' method:</span>
<span id="L358" class="LineNr">358 </span><span class="PreProc">type</span> <span class="Type">Block</span> <span class="Comment"># every block of code is an instance of this type</span>
<span id="L359" class="LineNr">359 </span>  [ <span class="Statement">void</span> whileTrue: [ <span class="Statement">void</span> value ] aBlock |
<span id="L360" class="LineNr">360 </span>    (<span class="Statement">self</span> value) ifTrue: [    <span class="Comment"># this will halt the program if the return value of 'self' is not Boolean</span>
<span id="L361" class="LineNr">361 </span>      aBlock value.
<span id="L362" class="LineNr">362 </span>      <span class="Statement">self</span> whileTrue: aBlock.
<span id="L363" class="LineNr">363 </span>    ].
<span id="L364" class="LineNr">364 </span>  ].
<span id="L365" class="LineNr">365 </span>
<span id="L366" class="LineNr">366 </span>
<span id="L367" class="LineNr">367 </span><span class="Comment">########## assertions ##########</span>
<span id="L368" class="LineNr">368 </span>
<span id="L369" class="LineNr">369 </span><span class="Comment"># this language implementes an 'assert' just like in C, with some differences:</span>
<span id="L370" class="LineNr">370 </span><span class="Comment">#</span>
<span id="L371" class="LineNr">371 </span><span class="Comment">#   assert(bool, char*);</span>
<span id="L372" class="LineNr">372 </span><span class="Comment">#</span>
<span id="L373" class="LineNr">373 </span><span class="Comment"># that function (in C) checks the value of the boolean parameter and if it's false then prints the message and halts the</span>
<span id="L374" class="LineNr">374 </span><span class="Comment"># program, that function is implemented like this:</span>
<span id="L375" class="LineNr">375 </span>[ assert: <span class="Type">Boolean</span> test onFalse: <span class="Type">String</span> message |
<span id="L376" class="LineNr">376 </span>  test ifFalse: [
<span id="L377" class="LineNr">377 </span>    <span class="Comment"># this prints the message and halts the program, just like exit(int) in C.</span>
<span id="L378" class="LineNr">378 </span>    abort message.
<span id="L379" class="LineNr">379 </span>  ].
<span id="L380" class="LineNr">380 </span>].
<span id="L381" class="LineNr">381 </span><span class="Comment"># and call it like this:</span>
<span id="L382" class="LineNr">382 </span>assert: (instance = <span class="Constant">null</span>) onFalse: <span class="Constant">&quot;The instance is not null&quot;</span>.
<span id="L383" class="LineNr">383 </span>
<span id="L384" class="LineNr">384 </span><span class="Comment"># but that's not all, you can define other asserts to help with other tests like these:</span>
<span id="L385" class="LineNr">385 </span>assert: instance onNull: <span class="Constant">&quot;The instance is null&quot;</span>.
<span id="L386" class="LineNr">386 </span>assert: instance onNotNull: <span class="Constant">&quot;The instance is not null&quot;</span>.
<span id="L387" class="LineNr">387 </span>assert: (a &gt; 4) onTrue: <span class="Constant">&quot;a is greater than 4&quot;</span>.
<span id="L388" class="LineNr">388 </span>
<span id="L389" class="LineNr">389 </span><span class="Comment"># the implementation of those methods</span>
<span id="L390" class="LineNr">390 </span>[ assert: <span class="Type">Object</span> anObject onNull: <span class="Type">String</span> message |
<span id="L391" class="LineNr">391 </span>  (anObject = <span class="Constant">null</span>) ifTrue: [
<span id="L392" class="LineNr">392 </span>    abort message.
<span id="L393" class="LineNr">393 </span>  ].
<span id="L394" class="LineNr">394 </span>].
<span id="L395" class="LineNr">395 </span>
<span id="L396" class="LineNr">396 </span>[ assert: <span class="Type">Object</span> anObject onNotNull: <span class="Type">String</span> message |
<span id="L397" class="LineNr">397 </span>  (anObject = <span class="Constant">null</span>) ifFalse: [
<span id="L398" class="LineNr">398 </span>    abort message.
<span id="L399" class="LineNr">399 </span>  ].
<span id="L400" class="LineNr">400 </span>].
<span id="L401" class="LineNr">401 </span>
<span id="L402" class="LineNr">402 </span>[ assert: <span class="Type">Boolean</span> test onTrue: <span class="Type">String</span> message |
<span id="L403" class="LineNr">403 </span>  test ifTrue: [
<span id="L404" class="LineNr">404 </span>    abort message.
<span id="L405" class="LineNr">405 </span>  ].
<span id="L406" class="LineNr">406 </span>].
<span id="L407" class="LineNr">407 </span>
<span id="L408" class="LineNr">408 </span><span class="Comment"># you can define your own assertions as you define any other block of code</span>
<span id="L409" class="LineNr">409 </span>
<span id="L410" class="LineNr">410 </span>
<span id="L411" class="LineNr">411 </span><span class="Comment">########## more types ##########</span>
<span id="L412" class="LineNr">412 </span>
<span id="L413" class="LineNr">413 </span><span class="Comment"># here is an example of an abstract type, if a type has at least 1 abstract method, then the whole type is abstract,</span>
<span id="L414" class="LineNr">414 </span><span class="Comment"># because you can't create a type that has a method without an implementation, an interface (like the ones in Java) is</span>
<span id="L415" class="LineNr">415 </span><span class="Comment"># implemented using a pure abstract type, a type that has not even one method implemented and no data associated with</span>
<span id="L416" class="LineNr">416 </span><span class="Comment"># it.</span>
<span id="L417" class="LineNr">417 </span><span class="PreProc">type</span> <span class="Type">Boolean</span>
<span id="L418" class="LineNr">418 </span>  <span class="Comment"># in C++ you can define a 'virtual = 0' function, but here you declare just their interfaces, not their bodies and</span>
<span id="L419" class="LineNr">419 </span>  <span class="Comment"># mark the method as 'abstract'</span>
<span id="L420" class="LineNr">420 </span>  <span class="PreProc">abstract</span> [ <span class="Statement">void</span> ifTrue: [ <span class="Statement">void</span> value ] ].
<span id="L421" class="LineNr">421 </span>  <span class="Comment"># in that last method called 'ifTrue:' it just returns nothing and receives a parameter (here the name is missing</span>
<span id="L422" class="LineNr">422 </span>  <span class="Comment"># because this is just an interface, not the real method) and that parameter is a block of code that doesn't return</span>
<span id="L423" class="LineNr">423 </span>  <span class="Comment"># anything and doesn't receive anything, the block declaration is '[ void value ]' because it must be evaluated like</span>
<span id="L424" class="LineNr">424 </span>  <span class="Comment"># this (asuming that the block's name is 'aBlock':</span>
<span id="L425" class="LineNr">425 </span>  <span class="Comment">#</span>
<span id="L426" class="LineNr">426 </span>  <span class="Comment">#   aBlock value.</span>
<span id="L427" class="LineNr">427 </span>  <span class="Comment">#</span>
<span id="L428" class="LineNr">428 </span>  <span class="Comment"># so you can define a block and pass it to 'ifTrue:' like this:</span>
<span id="L429" class="LineNr">429 </span>  <span class="Comment">#</span>
<span id="L430" class="LineNr">430 </span>  <span class="Comment"># Boolean aBool := true.</span>
<span id="L431" class="LineNr">431 </span>  <span class="Comment">#</span>
<span id="L432" class="LineNr">432 </span>  <span class="Comment"># aBool ifTrue: [ void value |</span>
<span id="L433" class="LineNr">433 </span>  <span class="Comment">#   ...</span>
<span id="L434" class="LineNr">434 </span>  <span class="Comment"># ].</span>
<span id="L435" class="LineNr">435 </span>
<span id="L436" class="LineNr">436 </span>  <span class="Comment"># Boolean has another method 'ifFalse:'</span>
<span id="L437" class="LineNr">437 </span>  <span class="Comment"># but this are interfaces, so parameters names are not required</span>
<span id="L438" class="LineNr">438 </span>  <span class="PreProc">abstract</span> [ <span class="Statement">void</span> ifFalse: [ <span class="Statement">void</span> value ] ].
<span id="L439" class="LineNr">439 </span>
<span id="L440" class="LineNr">440 </span>  <span class="Comment"># here is another interface with more parameters</span>
<span id="L441" class="LineNr">441 </span>  <span class="Comment"># again, this is an interface, so parameters with no names are fine</span>
<span id="L442" class="LineNr">442 </span>  <span class="PreProc">abstract</span> [ <span class="Statement">void</span> ifTrue: [ <span class="Statement">void</span> value ], ifFalse: [ <span class="Statement">void</span> value ] ].
<span id="L443" class="LineNr">443 </span>
<span id="L444" class="LineNr">444 </span>  <span class="Comment"># here is another interface</span>
<span id="L445" class="LineNr">445 </span>  <span class="Comment"># note that 'ifTrue:ifFalse' is not the same that 'ifFalse:ifTrue'</span>
<span id="L446" class="LineNr">446 </span>  <span class="PreProc">abstract</span> [ <span class="Statement">void</span> ifFalse: [ <span class="Statement">void</span> value ], ifTrue: [ <span class="Statement">void</span> value ] ].
<span id="L447" class="LineNr">447 </span>
<span id="L448" class="LineNr">448 </span>  <span class="Comment"># here is an interface that receives a block that returns something</span>
<span id="L449" class="LineNr">449 </span>  <span class="Comment"># 'or:' is a method that returns a Boolean and receives another block of code</span>
<span id="L450" class="LineNr">450 </span>  <span class="Comment"># that is evaluated if this object is True, so the block that receives must</span>
<span id="L451" class="LineNr">451 </span>  <span class="Comment"># return 'Boolean'</span>
<span id="L452" class="LineNr">452 </span>  <span class="PreProc">abstract</span> [ <span class="Type">Boolean</span> or [ <span class="Type">Boolean</span> value ] ].
<span id="L453" class="LineNr">453 </span>
<span id="L454" class="LineNr">454 </span>  <span class="Comment"># the same with and:</span>
<span id="L455" class="LineNr">455 </span>  <span class="PreProc">abstract</span> [ <span class="Type">Boolean</span> and [ <span class="Type">Boolean</span> value ] ].
<span id="L456" class="LineNr">456 </span>
<span id="L457" class="LineNr">457 </span><span class="Comment"># now, all those methods are just too verbose, for all the '[ void value ]' the compiler can assume 2 things: if the</span>
<span id="L458" class="LineNr">458 </span><span class="Comment"># method (or any block of code) doesn't have a return type, then it doesn't returns anything so you could just skip the</span>
<span id="L459" class="LineNr">459 </span><span class="Comment"># 'void' keyword, then the 'value', every block of code can be evaluated, so it must have a name, a way to call it, so</span>
<span id="L460" class="LineNr">460 </span><span class="Comment"># if any block has no header a 'value' is inserted to be able to evaluate it so '[ void value ]' can be written just</span>
<span id="L461" class="LineNr">461 </span><span class="Comment"># '[]', here is a better declaration of Boolean (without the comments):</span>
<span id="L462" class="LineNr">462 </span>
<span id="L463" class="LineNr">463 </span><span class="PreProc">type</span> <span class="Type">Boolean</span>
<span id="L464" class="LineNr">464 </span>  <span class="PreProc">abstract</span> [ ifTrue: [] ].
<span id="L465" class="LineNr">465 </span>  <span class="PreProc">abstract</span> [ ifFalse: [] ].
<span id="L466" class="LineNr">466 </span>  <span class="PreProc">abstract</span> [ ifTrue: [] ifFalse: [] ].
<span id="L467" class="LineNr">467 </span>  <span class="PreProc">abstract</span> [ ifFalse: [] ifTrue: [] ].
<span id="L468" class="LineNr">468 </span>  <span class="PreProc">abstract</span> [ <span class="Type">Boolean</span> or [ <span class="Type">Boolean</span> ] ].
<span id="L469" class="LineNr">469 </span>  <span class="PreProc">abstract</span> [ <span class="Type">Boolean</span> and [ <span class="Type">Boolean</span> ] ].
<span id="L470" class="LineNr">470 </span>
<span id="L471" class="LineNr">471 </span><span class="Comment"># and the calls to those methods:</span>
<span id="L472" class="LineNr">472 </span><span class="Type">Boolean</span> aBool := <span class="Constant">true</span>.
<span id="L473" class="LineNr">473 </span>
<span id="L474" class="LineNr">474 </span><span class="Comment"># declaring a method that doesn't return anything and has a 'value' name</span>
<span id="L475" class="LineNr">475 </span>aBool ifTrue: [ <span class="Statement">void</span> value |
<span id="L476" class="LineNr">476 </span>  <span class="Comment"># code...</span>
<span id="L477" class="LineNr">477 </span>].
<span id="L478" class="LineNr">478 </span>
<span id="L479" class="LineNr">479 </span><span class="Comment"># is the same to write just this (a method with a body but without a header)</span>
<span id="L480" class="LineNr">480 </span>aBool ifTrue: [
<span id="L481" class="LineNr">481 </span>  <span class="Comment"># code...</span>
<span id="L482" class="LineNr">482 </span>].
<span id="L483" class="LineNr">483 </span>
<span id="L484" class="LineNr">484 </span><span class="Comment"># or if without a explicit Boolean variable: (note the use of parenthesis)</span>
<span id="L485" class="LineNr">485 </span>(age &lt; 18) ifTrue: [
<span id="L486" class="LineNr">486 </span>  <span class="Comment"># code when age is less than 18</span>
<span id="L487" class="LineNr">487 </span>] ifFalse: [
<span id="L488" class="LineNr">488 </span>  <span class="Comment"># code when age is equals or greater than 18</span>
<span id="L489" class="LineNr">489 </span>].
<span id="L490" class="LineNr">490 </span>
<span id="L491" class="LineNr">491 </span><span class="Comment"># NOTE: maybe you are wondering why 'or' and 'and' both receive a block that returns a Boolean and not a Boolean itself,</span>
<span id="L492" class="LineNr">492 </span><span class="Comment"># that's to be able to perform lazy evaluation:</span>
<span id="L493" class="LineNr">493 </span><span class="Type">Driver</span> aDriver := <span class="Type">Driver</span> age: 15 license: <span class="Constant">false</span>.
<span id="L494" class="LineNr">494 </span>(aDriver age &gt; 18) and: [ aDriver hasLicense ] ifTrue: [
<span id="L495" class="LineNr">495 </span>  <span class="Comment"># code when a driver can drive a vehicle</span>
<span id="L496" class="LineNr">496 </span>].
<span id="L497" class="LineNr">497 </span><span class="Comment"># in the above code, if age is less than 18, then the block '[ aDriver hasLicense ]' is never executed, but if 'and:'</span>
<span id="L498" class="LineNr">498 </span><span class="Comment"># would receive a Boolean instead, first that block is evaluated to get the retunr value and then that value (true or</span>
<span id="L499" class="LineNr">499 </span><span class="Comment"># false) is passed to 'and:' method.</span>
<span id="L500" class="LineNr">500 </span>
<span id="L501" class="LineNr">501 </span><span class="Comment"># now an inheritance example, we can have simple inheritance only, never multiple inheritance</span>
<span id="L502" class="LineNr">502 </span><span class="PreProc">type</span> <span class="Type">True</span> <span class="PreProc">extends</span> <span class="Type">Boolean</span>
<span id="L503" class="LineNr">503 </span>  <span class="Comment"># by stating that a type 'extends' another type we are defining inheritance, as you can see there is a 'True' type</span>
<span id="L504" class="LineNr">504 </span>  <span class="Comment"># (also we will have a 'False' type) and with this is that all the boolean methods are implemented, please note that</span>
<span id="L505" class="LineNr">505 </span>  <span class="Comment"># as this is a concrete type, not an abstract one, the parameters in every method need a name to be evaluated inside</span>
<span id="L506" class="LineNr">506 </span>  <span class="Comment"># the method code and a vertical bar '|' is used to separate the header of the method from it's body:</span>
<span id="L507" class="LineNr">507 </span>  [ ifTrue: [] aBlock |
<span id="L508" class="LineNr">508 </span>    <span class="Comment"># evaluate 'aBlock' since the receiver is true.</span>
<span id="L509" class="LineNr">509 </span>    aBlock value.
<span id="L510" class="LineNr">510 </span>  ].
<span id="L511" class="LineNr">511 </span>
<span id="L512" class="LineNr">512 </span>  [ ifFalse: [] aBlock |
<span id="L513" class="LineNr">513 </span>    <span class="Comment"># do nothing since the receiver is true, this method will be replaced by nothing in the final compiled code</span>
<span id="L514" class="LineNr">514 </span>  ].
<span id="L515" class="LineNr">515 </span>
<span id="L516" class="LineNr">516 </span>  [ ifTrue: [] trueBlock ifFalse: [] falseBlock |
<span id="L517" class="LineNr">517 </span>    <span class="Comment"># evaluate 'trueBlock' since the receiver is true.</span>
<span id="L518" class="LineNr">518 </span>    trueBlock value.
<span id="L519" class="LineNr">519 </span>  ].
<span id="L520" class="LineNr">520 </span>
<span id="L521" class="LineNr">521 </span>  [ ifFalse: [] falseBlock ifTrue: [] trueBlock |
<span id="L522" class="LineNr">522 </span>    <span class="Comment"># evaluate 'trueBlock' since the receiver is true.</span>
<span id="L523" class="LineNr">523 </span>    trueBlock value.
<span id="L524" class="LineNr">524 </span>  ].
<span id="L525" class="LineNr">525 </span>
<span id="L526" class="LineNr">526 </span>  [ <span class="Type">Boolean</span> or [ <span class="Type">Boolean</span> ] aBlock |
<span id="L527" class="LineNr">527 </span>    <span class="Comment"># answer self since the receiver is true, here you can see the lazy evaluation: 'aBlock' is never evaluated when the</span>
<span id="L528" class="LineNr">528 </span>    <span class="Comment"># receiver of 'or' method is the true object.</span>
<span id="L529" class="LineNr">529 </span>    <span class="Statement">return</span> <span class="Statement">self</span>.
<span id="L530" class="LineNr">530 </span>  ].
<span id="L531" class="LineNr">531 </span>
<span id="L532" class="LineNr">532 </span>  [ <span class="Type">Boolean</span> and [ <span class="Type">Boolean</span> ] aBlock |
<span id="L533" class="LineNr">533 </span>    <span class="Comment"># answer the result of evaluating aBlock since the receiver is true, again the lazy evaluation: 'aBlock' is</span>
<span id="L534" class="LineNr">534 </span>    <span class="Comment"># evaluated here because the left part of the and is the true object, so the block must be evaluated to see if the</span>
<span id="L535" class="LineNr">535 </span>    <span class="Comment"># whole method 'and' is true or false.</span>
<span id="L536" class="LineNr">536 </span>    <span class="Statement">return</span> aBlock value.
<span id="L537" class="LineNr">537 </span>  ].
<span id="L538" class="LineNr">538 </span>
<span id="L539" class="LineNr">539 </span>
<span id="L540" class="LineNr">540 </span><span class="Comment"># here is the False declaration</span>
<span id="L541" class="LineNr">541 </span><span class="PreProc">type</span> <span class="Type">False</span> <span class="PreProc">extends</span> <span class="Type">Boolean</span>
<span id="L542" class="LineNr">542 </span>  [ ifTrue: [] aBlock |
<span id="L543" class="LineNr">543 </span>    <span class="Comment"># do nothing since the receiver is false, this method will be replaced by nothing in the final compiled code</span>
<span id="L544" class="LineNr">544 </span>  ].
<span id="L545" class="LineNr">545 </span>
<span id="L546" class="LineNr">546 </span>  [ ifFalse: [] aBlock |
<span id="L547" class="LineNr">547 </span>    <span class="Comment"># evaluate 'aBlock' since the receiver is false.</span>
<span id="L548" class="LineNr">548 </span>    aBlock value.
<span id="L549" class="LineNr">549 </span>  ].
<span id="L550" class="LineNr">550 </span>
<span id="L551" class="LineNr">551 </span>  [ ifTrue: [] trueBlock ifFalse: [] falseBlock |
<span id="L552" class="LineNr">552 </span>    <span class="Comment"># evaluate 'falseBlock' since the receiver is false.</span>
<span id="L553" class="LineNr">553 </span>    falseBlock value.
<span id="L554" class="LineNr">554 </span>  ].
<span id="L555" class="LineNr">555 </span>
<span id="L556" class="LineNr">556 </span>  [ ifFalse: [] falseBlock ifTrue: [] trueBlock |
<span id="L557" class="LineNr">557 </span>    <span class="Comment"># evaluate 'falseBlock' since the receiver is false.</span>
<span id="L558" class="LineNr">558 </span>    falseBlock value.
<span id="L559" class="LineNr">559 </span>  ].
<span id="L560" class="LineNr">560 </span>
<span id="L561" class="LineNr">561 </span>  [ <span class="Type">Boolean</span> or [ <span class="Type">Boolean</span> ] aBlock |
<span id="L562" class="LineNr">562 </span>    <span class="Comment"># answer the result of evaluating aBlock since the receiver is false.</span>
<span id="L563" class="LineNr">563 </span>    <span class="Statement">return</span> aBlock value.
<span id="L564" class="LineNr">564 </span>  ].
<span id="L565" class="LineNr">565 </span>
<span id="L566" class="LineNr">566 </span>  [ <span class="Type">Boolean</span> and [ <span class="Type">Boolean</span> ] aBlock |
<span id="L567" class="LineNr">567 </span>    <span class="Comment"># answer self since the receiver is false.</span>
<span id="L568" class="LineNr">568 </span>    <span class="Statement">return</span> <span class="Statement">self</span>.
<span id="L569" class="LineNr">569 </span>  ].
<span id="L570" class="LineNr">570 </span>
<span id="L571" class="LineNr">571 </span>
<span id="L572" class="LineNr">572 </span><span class="Comment"># NOTE: there are two global variables in the environment: 'true' and 'false', both are instances of types 'True' and</span>
<span id="L573" class="LineNr">573 </span><span class="Comment"># 'False', this special variables can't be overridden, the compiler will see that as an error.</span>
<span id="L574" class="LineNr">574 </span><span class="PreProc">type</span> <span class="Type">Boolean</span>
<span id="L575" class="LineNr">575 </span>  <span class="Comment"># any type can be initialized to 'null' or with the value of other method or literal.</span>
<span id="L576" class="LineNr">576 </span>  <span class="Type">Boolean</span> instance := <span class="Type">Boolean</span> new.
<span id="L577" class="LineNr">577 </span>
<span id="L578" class="LineNr">578 </span>  <span class="Comment"># a method to retrieve the only instance of this type</span>
<span id="L579" class="LineNr">579 </span>  <span class="PreProc">static</span> [ <span class="Type">Boolean</span> instance |
<span id="L580" class="LineNr">580 </span>    <span class="Statement">return</span> instance.
<span id="L581" class="LineNr">581 </span>  ].
<span id="L582" class="LineNr">582 </span>
<span id="L583" class="LineNr">583 </span>  <span class="Comment"># an abstract method that defines how a Boolean is created, this can be overridden by the types that extends this one:</span>
<span id="L584" class="LineNr">584 </span>  <span class="Comment"># True and False respectively.</span>
<span id="L585" class="LineNr">585 </span>  <span class="PreProc">abstract</span> <span class="PreProc">static</span> [ <span class="Type">Boolean</span> new ].
<span id="L586" class="LineNr">586 </span>
<span id="L587" class="LineNr">587 </span><span class="PreProc">type</span> <span class="Type">True</span> <span class="PreProc">extends</span> <span class="Type">Boolean</span>
<span id="L588" class="LineNr">588 </span>  <span class="Comment"># here is the 'new' method that returns a new instance of a type</span>
<span id="L589" class="LineNr">589 </span>  <span class="PreProc">static</span> [ <span class="Type">Boolean</span> new |
<span id="L590" class="LineNr">590 </span>    assert: instance onNotNull: <span class="Constant">&quot;true was already created, use 'True instance' or just 'true' instead&quot;</span>.
<span id="L591" class="LineNr">591 </span>    <span class="Comment"># here is a special call: it tells the 'system' to allocate (and return) a new object of type 'True'</span>
<span id="L592" class="LineNr">592 </span>    <span class="Statement">return</span> <span class="Type">System</span> alloc: <span class="Type">True</span>.
<span id="L593" class="LineNr">593 </span>  ].
<span id="L594" class="LineNr">594 </span>
<span id="L595" class="LineNr">595 </span><span class="Comment"># same for False</span>
<span id="L596" class="LineNr">596 </span><span class="PreProc">type</span> <span class="Type">False</span> <span class="PreProc">extends</span> <span class="Type">Boolean</span>
<span id="L597" class="LineNr">597 </span>  <span class="PreProc">static</span> [ <span class="Type">Boolean</span> new |
<span id="L598" class="LineNr">598 </span>    assert: instance onNotNull: <span class="Constant">&quot;false was already created, use 'False instance' or just 'false' instead&quot;</span>.
<span id="L599" class="LineNr">599 </span>    <span class="Statement">return</span> <span class="Type">System</span> alloc: <span class="Type">False</span>.
<span id="L600" class="LineNr">600 </span>  ].
<span id="L601" class="LineNr">601 </span>
<span id="L602" class="LineNr">602 </span><span class="Comment"># maybe you noticed that severtal times a write a type with just one method and then we write the same type again with</span>
<span id="L603" class="LineNr">603 </span><span class="Comment"># other method, well that is legal code, you can write a partial type and in the future add a new method to it.</span>
<span id="L604" class="LineNr">604 </span>
<span id="L605" class="LineNr">605 </span>
<span id="L606" class="LineNr">606 </span><span class="Comment">########## operators ##########</span>
<span id="L607" class="LineNr">607 </span><span class="Comment"># a few languages has something called operators, they are some constructs in the language that allow to call a block of</span>
<span id="L608" class="LineNr">608 </span><span class="Comment"># code in a different way, for example, in C++ and Java you call blocks of code using the identifier of an object and</span>
<span id="L609" class="LineNr">609 </span><span class="Comment"># then (separated with a dot '.') the name of the method to call:</span>
<span id="L610" class="LineNr">610 </span><span class="Comment">#</span>
<span id="L611" class="LineNr">611 </span><span class="Comment">#   anObject.aMethod();</span>
<span id="L612" class="LineNr">612 </span><span class="Comment">#</span>
<span id="L613" class="LineNr">613 </span><span class="Comment"># so, in that languajes to perform tasks as this:</span>
<span id="L614" class="LineNr">614 </span><span class="Comment">#</span>
<span id="L615" class="LineNr">615 </span><span class="Comment">#   4 + 5;</span>
<span id="L616" class="LineNr">616 </span><span class="Comment">#</span>
<span id="L617" class="LineNr">617 </span><span class="Comment"># you need to define a new way to call a function, here operators are introduced, but to make things simple, in this</span>
<span id="L618" class="LineNr">618 </span><span class="Comment"># language you don't have to write a different thing, if you see again the statement above you'll se the next structure:</span>
<span id="L619" class="LineNr">619 </span><span class="Comment">#</span>
<span id="L620" class="LineNr">620 </span><span class="Comment">#   Number + Number.</span>
<span id="L621" class="LineNr">621 </span><span class="Comment">#</span>
<span id="L622" class="LineNr">622 </span><span class="Comment"># and even so:</span>
<span id="L623" class="LineNr">623 </span><span class="Comment">#</span>
<span id="L624" class="LineNr">624 </span><span class="Comment">#   object message object.</span>
<span id="L625" class="LineNr">625 </span><span class="Comment">#</span>
<span id="L626" class="LineNr">626 </span><span class="Comment"># that's valid code for this language, so here is the Number type with some operators:</span>
<span id="L627" class="LineNr">627 </span><span class="PreProc">type</span> <span class="Type">Number</span>
<span id="L628" class="LineNr">628 </span>  [ <span class="Type">Number</span> + <span class="Type">Number</span> a |
<span id="L629" class="LineNr">629 </span>    <span class="Comment"># code to add self and 'a'.</span>
<span id="L630" class="LineNr">630 </span>  ].
<span id="L631" class="LineNr">631 </span>
<span id="L632" class="LineNr">632 </span>  [ <span class="Type">Number</span> - <span class="Type">Number</span> a |
<span id="L633" class="LineNr">633 </span>    <span class="Comment"># code to substract 'a' from self.</span>
<span id="L634" class="LineNr">634 </span>  ].
<span id="L635" class="LineNr">635 </span>
<span id="L636" class="LineNr">636 </span>  <span class="Comment"># this also works with comparison operators:</span>
<span id="L637" class="LineNr">637 </span>  [ <span class="Type">Boolean</span> &lt; <span class="Type">Number</span> a |
<span id="L638" class="LineNr">638 </span>    <span class="Comment"># code to check if self is less than 'a'.</span>
<span id="L639" class="LineNr">639 </span>  ].
<span id="L640" class="LineNr">640 </span>
<span id="L641" class="LineNr">641 </span>  [ <span class="Type">Boolean</span> = <span class="Type">Number</span> a |
<span id="L642" class="LineNr">642 </span>    <span class="Comment"># code to check if self is equals to 'a'.</span>
<span id="L643" class="LineNr">643 </span>  ].
<span id="L644" class="LineNr">644 </span>
<span id="L645" class="LineNr">645 </span><span class="Comment"># you can define all the operators (existing or not) in your own types, the '+' is not part of the language as is in C,</span>
<span id="L646" class="LineNr">646 </span><span class="Comment"># C++ or Java, the '+' is just another method name that can be used as you will use 'add' or 'sum' or any other name you</span>
<span id="L647" class="LineNr">647 </span><span class="Comment"># want to use.</span>
<span id="L648" class="LineNr">648 </span>
<span id="L649" class="LineNr">649 </span><span class="Comment"># but with numbers there is a special case, this methods: add, substract, multiply, etc. are a lot better if they are</span>
<span id="L650" class="LineNr">650 </span><span class="Comment"># performed by the CPU directly, so this methods (in the real code) will be defined as 'primitive' methods:</span>
<span id="L651" class="LineNr">651 </span><span class="PreProc">type</span> <span class="Type">Number</span>
<span id="L652" class="LineNr">652 </span>  <span class="PreProc">primitive</span> [ <span class="Type">Number</span> + <span class="Type">Number</span> ].
<span id="L653" class="LineNr">653 </span>  <span class="PreProc">primitive</span> [ <span class="Type">Number</span> - <span class="Type">Number</span> ].
<span id="L654" class="LineNr">654 </span>  <span class="PreProc">primitive</span> [ <span class="Type">Boolean</span> &lt; <span class="Type">Number</span> ].
<span id="L655" class="LineNr">655 </span>  <span class="PreProc">primitive</span> [ <span class="Type">Boolean</span> = <span class="Type">Number</span> ].
<span id="L656" class="LineNr">656 </span><span class="Comment"># the 'primitive' keyword states that those methods are not written in this language, they are written directly in</span>
<span id="L657" class="LineNr">657 </span><span class="Comment"># machine code by the compiler, later we will be able to write our own primitive methods to extend the language.</span>
<span id="L658" class="LineNr">658 </span>
<span id="L659" class="LineNr">659 </span>
<span id="L660" class="LineNr">660 </span><span class="Comment">########## control structures ##########</span>
<span id="L661" class="LineNr">661 </span>
<span id="L662" class="LineNr">662 </span><span class="Comment"># as a student we learned that any program can be written with just 3 structures:</span>
<span id="L663" class="LineNr">663 </span><span class="Comment">#</span>
<span id="L664" class="LineNr">664 </span><span class="Comment"># when you read the next diagrams just have in mind that:</span>
<span id="L665" class="LineNr">665 </span><span class="Comment">#</span>
<span id="L666" class="LineNr">666 </span><span class="Comment">#     linear:              branch:              loop:</span>
<span id="L667" class="LineNr">667 </span><span class="Comment"># perform a task      select wich task      perform a task</span>
<span id="L668" class="LineNr">668 </span><span class="Comment">#  after another         to perform          several times</span>
<span id="L669" class="LineNr">669 </span><span class="Comment">#</span>
<span id="L670" class="LineNr">670 </span><span class="Comment">#        O                    O                   O</span>
<span id="L671" class="LineNr">671 </span><span class="Comment">#        |                    |                   |</span>
<span id="L672" class="LineNr">672 </span><span class="Comment">#       [ ]                --/ /--               [ ]&lt;--</span>
<span id="L673" class="LineNr">673 </span><span class="Comment">#        |                 |     |                |   |</span>
<span id="L674" class="LineNr">674 </span><span class="Comment">#       [ ]               [ ]   [ ]              / /---</span>
<span id="L675" class="LineNr">675 </span><span class="Comment">#        |                 |     |                |</span>
<span id="L676" class="LineNr">676 </span><span class="Comment">#        X                 -------                X</span>
<span id="L677" class="LineNr">677 </span><span class="Comment">#                             |</span>
<span id="L678" class="LineNr">678 </span><span class="Comment">#                             X</span>
<span id="L679" class="LineNr">679 </span><span class="Comment">#</span>
<span id="L680" class="LineNr">680 </span><span class="Comment"># how to read those diagrams</span>
<span id="L681" class="LineNr">681 </span><span class="Comment">#   O   marks the start of the program</span>
<span id="L682" class="LineNr">682 </span><span class="Comment">#   [ ] marks the execution of some task</span>
<span id="L683" class="LineNr">683 </span><span class="Comment">#   / / marks a decision</span>
<span id="L684" class="LineNr">684 </span><span class="Comment">#   X   marks the end of the program</span>
<span id="L685" class="LineNr">685 </span><span class="Comment">#   |   just connects one statement with another</span>
<span id="L686" class="LineNr">686 </span><span class="Comment">#</span>
<span id="L687" class="LineNr">687 </span><span class="Comment"># the linear execution is just a statement of the language after another, most languages has this (with few exceptions)</span>
<span id="L688" class="LineNr">688 </span><span class="Comment"># but the branch and the loop are implemented in very different ways depending on the language, in C-like family</span>
<span id="L689" class="LineNr">689 </span><span class="Comment"># languages, they use some constructs that are hard coded in the compiler:</span>
<span id="L690" class="LineNr">690 </span><span class="Comment">#</span>
<span id="L691" class="LineNr">691 </span><span class="Comment">#   branches: if, if else, if elseif, and switch</span>
<span id="L692" class="LineNr">692 </span><span class="Comment">#</span>
<span id="L693" class="LineNr">693 </span><span class="Comment">#   loops: for, while, do while</span>
<span id="L694" class="LineNr">694 </span><span class="Comment">#</span>
<span id="L695" class="LineNr">695 </span><span class="Comment"># but in this language those constructs are not present, there is no such thing as a 'while' keyword or 'if' statement,</span>
<span id="L696" class="LineNr">696 </span><span class="Comment"># instead ther are messages passed to objects of type Boolean that perform the same tasks, we already see this in the</span>
<span id="L697" class="LineNr">697 </span><span class="Comment"># Boolean type definition, every boolean object (remember, there are two boolean objects: 'true' and 'false') has a</span>
<span id="L698" class="LineNr">698 </span><span class="Comment"># collection of methods to evaluate a block or not, this collection of methods are use to implemente the branches:</span>
<span id="L699" class="LineNr">699 </span><span class="PreProc">type</span> <span class="Type">Boolean</span>
<span id="L700" class="LineNr">700 </span>  <span class="PreProc">abstract</span> [ ifTrue: [] ].
<span id="L701" class="LineNr">701 </span>  <span class="PreProc">abstract</span> [ ifFalse: [] ].
<span id="L702" class="LineNr">702 </span>  <span class="PreProc">abstract</span> [ ifTrue: [] ifFalse: [] ].
<span id="L703" class="LineNr">703 </span>  <span class="PreProc">abstract</span> [ ifFalse: [] ifTrue: [] ].
<span id="L704" class="LineNr">704 </span>
<span id="L705" class="LineNr">705 </span><span class="Comment"># the loops are implemented in the Block type we saw before a 'whileTrue' method, here is again without all the 'void'</span>
<span id="L706" class="LineNr">706 </span><span class="Comment"># declarations</span>
<span id="L707" class="LineNr">707 </span><span class="PreProc">type</span> <span class="Type">Block</span>
<span id="L708" class="LineNr">708 </span>  <span class="Comment"># this method works just like a 'while (bool) {}' in C</span>
<span id="L709" class="LineNr">709 </span>  [ whileTrue: [] aBlock |
<span id="L710" class="LineNr">710 </span>    (<span class="Statement">self</span> value) ifTrue: [
<span id="L711" class="LineNr">711 </span>      aBlock value.
<span id="L712" class="LineNr">712 </span>      <span class="Statement">self</span> whileTrue: aBlock. <span class="Comment"># recursive call</span>
<span id="L713" class="LineNr">713 </span>    ].
<span id="L714" class="LineNr">714 </span>  ].
<span id="L715" class="LineNr">715 </span>
<span id="L716" class="LineNr">716 </span>  <span class="Comment"># this method works just like a 'do {} while(bool)' in C</span>
<span id="L717" class="LineNr">717 </span>  [ whileTrue |
<span id="L718" class="LineNr">718 </span>    (<span class="Statement">self</span> value) ifTrue: [
<span id="L719" class="LineNr">719 </span>      <span class="Statement">self</span> whileTrue.
<span id="L720" class="LineNr">720 </span>    ].
<span id="L721" class="LineNr">721 </span>  ].
<span id="L722" class="LineNr">722 </span>
<span id="L723" class="LineNr">723 </span><span class="Comment"># and a range loop is implemented in the Number type, note that this uses the 'whileTrue: []' from Block</span>
<span id="L724" class="LineNr">724 </span><span class="PreProc">type</span> <span class="Type">Number</span>
<span id="L725" class="LineNr">725 </span>  <span class="Comment"># this method works just like a 'for (...) {}' in C</span>
<span id="L726" class="LineNr">726 </span>  [ to: <span class="Type">Number</span> end by: <span class="Type">Number</span> step do: [] aBlock |
<span id="L727" class="LineNr">727 </span>    <span class="Type">Number</span> index := <span class="Statement">self</span>.
<span id="L728" class="LineNr">728 </span>    [ current &lt; end ] whileTrue: [
<span id="L729" class="LineNr">729 </span>      aBlock value.
<span id="L730" class="LineNr">730 </span>      index := index + step.
<span id="L731" class="LineNr">731 </span>    ].
<span id="L732" class="LineNr">732 </span>  ].
<span id="L733" class="LineNr">733 </span>
<span id="L734" class="LineNr">734 </span><span class="Comment"># of course we can have other methods like 'whileFalse' in Block but as you can see you can define those methods</span>
<span id="L735" class="LineNr">735 </span><span class="Comment"># yourself with no problem.</span>
<span id="L736" class="LineNr">736 </span>
<span id="L737" class="LineNr">737 </span>
<span id="L738" class="LineNr">738 </span><span class="Comment"># TODO:</span>
<span id="L739" class="LineNr">739 </span><span class="Comment">#</span>
<span id="L740" class="LineNr">740 </span><span class="Comment"># Data structures:</span>
<span id="L741" class="LineNr">741 </span><span class="Comment">#   * list, vector or array (a list of objects)</span>
<span id="L742" class="LineNr">742 </span><span class="Comment">#   * map, dictionarie, hashtable (a table of objects associated with other objects)</span>
<span id="L743" class="LineNr">743 </span><span class="Comment">#</span>
<span id="L744" class="LineNr">744 </span><span class="Comment"># Parametrizized types?</span>
<span id="L745" class="LineNr">745 </span><span class="Comment">#   maybe with templates like C++ or just with a type as it's argument</span>
<span id="L746" class="LineNr">746 </span>
<span id="L747" class="LineNr">747 </span><span class="Comment">########## OLD THINGS (will be changed) ###########</span>
<span id="L748" class="LineNr">748 </span><span class="Comment"># as in C++ and C# you can have templates (or Generics)</span>
<span id="L749" class="LineNr">749 </span><span class="Comment"># here is a list (this is like a C array, a contiguous piece of memory)</span>
<span id="L750" class="LineNr">750 </span><span class="Comment"># List&lt;String&gt; aListOfStrings := List&lt;String&gt; new: 40.</span>
<span id="L751" class="LineNr">751 </span><span class="Comment"># </span>
<span id="L752" class="LineNr">752 </span><span class="Comment"># here is a map</span>
<span id="L753" class="LineNr">753 </span><span class="Comment"># Map&lt;String, Object&gt; aDictionary := Dictionary&lt;String, Object&gt; new.</span>
<span id="L754" class="LineNr">754 </span><span class="Comment"># </span>
<span id="L755" class="LineNr">755 </span><span class="Comment"># here is a definition of List&lt;T&gt;</span>
<span id="L756" class="LineNr">756 </span><span class="Comment"># type List&lt;ValueType&gt;</span>
<span id="L757" class="LineNr">757 </span><span class="Comment">#   Number size := 0.</span>
<span id="L758" class="LineNr">758 </span><span class="Comment"># </span>
<span id="L759" class="LineNr">759 </span><span class="Comment">#   # new is implemented primitively</span>
<span id="L760" class="LineNr">760 </span><span class="Comment">#   primitive static [ List&lt;ValueType&gt; new: Number size ].</span>
<span id="L761" class="LineNr">761 </span><span class="Comment"># </span>
<span id="L762" class="LineNr">762 </span><span class="Comment">#   # accesors like [] in C to get and set values at different indices</span>
<span id="L763" class="LineNr">763 </span><span class="Comment">#   primitive [ ValueType at: Number index ].</span>
<span id="L764" class="LineNr">764 </span><span class="Comment"># </span>
<span id="L765" class="LineNr">765 </span><span class="Comment">#   primitive [ at: Number index, set: ValueType value ].</span>
<span id="L766" class="LineNr">766 </span><span class="Comment"># </span>
<span id="L767" class="LineNr">767 </span><span class="Comment">#   # for each...</span>
<span id="L768" class="LineNr">768 </span><span class="Comment">#   [ forEach: Block&lt;value: ValueType&gt; do |</span>
<span id="L769" class="LineNr">769 </span><span class="Comment">#     0 to: size do: [ value: Number step |</span>
<span id="L770" class="LineNr">770 </span><span class="Comment">#       do value: (self at: step).</span>
<span id="L771" class="LineNr">771 </span><span class="Comment">#     ].</span>
<span id="L772" class="LineNr">772 </span><span class="Comment">#   ].</span>
<span id="L773" class="LineNr">773 </span><span class="Comment"># </span>
<span id="L774" class="LineNr">774 </span><span class="Comment">#   [ forEach: Block&lt;value: ValueType, index: Number&gt; do |</span>
<span id="L775" class="LineNr">775 </span><span class="Comment">#     0 to: size do: [ value: Number step |</span>
<span id="L776" class="LineNr">776 </span><span class="Comment">#       do value: (self at: step) index: step.</span>
<span id="L777" class="LineNr">777 </span><span class="Comment">#     ].</span>
<span id="L778" class="LineNr">778 </span><span class="Comment">#   ].</span>
<span id="L779" class="LineNr">779 </span><span class="Comment"># </span>
<span id="L780" class="LineNr">780 </span><span class="Comment">#   [ forEach: Block&lt;value: ValueType&gt; do, while: Block&lt;Boolean&gt; condition |</span>
<span id="L781" class="LineNr">781 </span><span class="Comment">#     Number step := 0.</span>
<span id="L782" class="LineNr">782 </span><span class="Comment">#     [ Boolean | return (step &lt;= size) and: condition. ] whileTrue: [</span>
<span id="L783" class="LineNr">783 </span><span class="Comment">#       do value: (self at: step).</span>
<span id="L784" class="LineNr">784 </span><span class="Comment">#       step += 1.</span>
<span id="L785" class="LineNr">785 </span><span class="Comment">#     ].</span>
<span id="L786" class="LineNr">786 </span><span class="Comment">#   ].</span>
<span id="L787" class="LineNr">787 </span><span class="Comment"># </span>
<span id="L788" class="LineNr">788 </span><span class="Comment">#   [ forEach: Block&lt;value: ValueType, index: Number&gt; do, while: Block&lt;Boolean&gt; condition |</span>
<span id="L789" class="LineNr">789 </span><span class="Comment">#     Number step := 0.</span>
<span id="L790" class="LineNr">790 </span><span class="Comment">#     [ Boolean | return (step &lt;= size) and: condition. ] whileTrue: [</span>
<span id="L791" class="LineNr">791 </span><span class="Comment">#       do value: (self at: step) index: step.</span>
<span id="L792" class="LineNr">792 </span><span class="Comment">#       step += 1.</span>
<span id="L793" class="LineNr">793 </span><span class="Comment">#     ].</span>
<span id="L794" class="LineNr">794 </span><span class="Comment">#   ].</span>
<span id="L795" class="LineNr">795 </span><span class="Comment"># </span>
<span id="L796" class="LineNr">796 </span><span class="Comment"># here is a definition of map (not very optimal, but one at least)</span>
<span id="L797" class="LineNr">797 </span><span class="Comment"># type Map&lt;KeyType, ValueType&gt;</span>
<span id="L798" class="LineNr">798 </span><span class="Comment">#   List&lt;KeyType&gt; keys.</span>
<span id="L799" class="LineNr">799 </span><span class="Comment">#   List&lt;ValueType&gt; values.</span>
<span id="L800" class="LineNr">800 </span><span class="Comment"># </span>
<span id="L801" class="LineNr">801 </span><span class="Comment">#   # new is implemented primitively</span>
<span id="L802" class="LineNr">802 </span><span class="Comment">#   primitive static [ Map&lt;KeyType, ValueType&gt; new ].</span>
<span id="L803" class="LineNr">803 </span><span class="Comment"># </span>
<span id="L804" class="LineNr">804 </span><span class="Comment">#   [ Number indexFor: KeyType key |</span>
<span id="L805" class="LineNr">805 </span><span class="Comment">#     Number index := -1.</span>
<span id="L806" class="LineNr">806 </span><span class="Comment">#     keys forEach: [ value: KeyType otherKey, index: Number currentIndex |</span>
<span id="L807" class="LineNr">807 </span><span class="Comment">#       (aKey = otherKey) ifTrue: [</span>
<span id="L808" class="LineNr">808 </span><span class="Comment">#         index := currentIndex.</span>
<span id="L809" class="LineNr">809 </span><span class="Comment">#       ].</span>
<span id="L810" class="LineNr">810 </span><span class="Comment">#     ] while: [</span>
<span id="L811" class="LineNr">811 </span><span class="Comment">#       return index != -1.</span>
<span id="L812" class="LineNr">812 </span><span class="Comment">#     ].</span>
<span id="L813" class="LineNr">813 </span><span class="Comment">#     return index.</span>
<span id="L814" class="LineNr">814 </span><span class="Comment">#   ].</span>
<span id="L815" class="LineNr">815 </span><span class="Comment"># </span>
<span id="L816" class="LineNr">816 </span><span class="Comment">#   [ ValueType at: KeyType aKey |</span>
<span id="L817" class="LineNr">817 </span><span class="Comment">#     return values at: (self indexFor: aKey).</span>
<span id="L818" class="LineNr">818 </span><span class="Comment">#   ].</span>
<span id="L819" class="LineNr">819 </span><span class="Comment"># </span>
<span id="L820" class="LineNr">820 </span><span class="Comment">#   [ at: KeyType key, set: ValueType newValue |</span>
<span id="L821" class="LineNr">821 </span><span class="Comment">#     values at: (self indexFor: aKey) set: newValue.</span>
<span id="L822" class="LineNr">822 </span><span class="Comment">#   ].</span>
<span id="L823" class="LineNr">823 </span>
<span id="L824" class="LineNr">824 </span><span class="Comment"># vim&#0058; tabstop=2:shiftwidth=2:softtabstop=2:filetype=nl</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
